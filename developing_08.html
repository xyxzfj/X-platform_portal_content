<!doctype html>
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Push Notification</title>
    <link rel="stylesheet" href="./assets/css/style.css">
    <link rel="stylesheet" href="css/templete.css" type="text/css" media="all" />
    <meta charset="UTF-8">
</head>
<body class="level-2">
    <div class="wrapper">
        <!--Begin header-->
        <div class="header">
            <div class="grid-container clearfix">
                <div class="header-left">
                    <img alt="Microsoft" src="http://i.s-microsoft.com/global/ImageStore/PublishingImages/logos/hp/logo-lg-1x.png" width="94" height="20">
                    <h1>X-Platform</h1>
                </div>
                <div id="mscom-search" class="mscom-search" style="margin-top: 37px;">
                    <div class="search-form">
                        <form action="" id="search-form">
                            <div class="input-wrapper">
                                <label class="screen-reader-text" for="search-input">搜索 Microsoft.com</label>
                                <input id="search-input" type="text" class="input-area" autocomplete="off">
                            </div>
                            <button class="search-submit" id="search-btn" type="submit">
                                <img width="16" height="16" alt="Submit" src="http://i.s-microsoft.com/global/imagestore/PublishingImages/sprites/search-button-blue.png"></button>
                        </form>
                    </div>
                    <div class="search-results-box" id="results">
                        <div class="search-scope">
                            <ul>
                                <li class=""><a class="checked" search="microsoft" role="search">搜索 Microsoft.com</a></li>
                                <li class=""><a search="internet" role="search">搜索互联网</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!--End header-->
        <br />
        <!--Begin Content-->
        <div class="content">
            <div class="wrapper">
                <div class="wrapper-header">
                    <div>
                        <a href="index.html">
                            <img src="./assets/image/banner_1.jpg"></a>
                    </div>
                </div>
                <div class="main">
                    <div class="nav">
                        <div class="block article-nav-block">
                            <h2>移动应用开发生命周期</h2>
                            <div class="menu">
                                <h3><a href="idea.html">计划<span>Idea/Planning</span></a></h3>
                                <ul>
                                    <li><a href="idea_01.html">平台总览</a></li>
                                    <li><a href="idea_02.html">开发工具、开发环境和模拟器</a></li>
                                    <li><a href="idea_03.html">应用结构和生命周期</a></li>
                                </ul>
                            </div>
                            <div class="menu">
                                <h3><a href="design.html">设计<span>Design</span></a></h3>
                                <ul>
                                    <li><a href="design_01.html">UI Layout的设计</a></li>
                                    <li><a href="design_02.html">UI的控件</a></li>
                                    <li><a href="design_03.html">UI页面的控制和导航</a></li>
                                    <li><a href="design_04.html">不同屏幕尺寸和分辨率的适配</a></li>
                                    <li><a href="design_05.html">第三方SDK</a></li>
                                    <li><a href="design_06.html">游戏开发</a></li>
                                </ul>
                            </div>
                            <div class="menu active">
                                <h3><a href="developing.html">开发<span>Developing</span></a></h3>
                                <ul>
                                    <li><a href="developing_01.html">开发语言</a></li>
                                    <li><a href="developing_02.html">Audio、Video Player应用的开发</a></li>
                                    <li><a href="developing_03.html">General APIs Mapping</a></li>
                                    <li><a href="developing_04.html">IAP应用内支付</a></li>
                                    <li><a href="developing_05.html">LBS应用</a></li>
                                    <li><a href="developing_06.html">LBS、镜头和传感器应用接口使用</a></li>
                                    <li><a href="developing_07.html">Native Code（C和C++）支持</a></li>
                                    <li><a href="developing_08.html">Push Notification</a></li>
                                    <li><a href="developing_09.html">Sharing in Social Network</a></li>
                                    <li><a href="developing_10.html">Source Code Control</a></li>
                                    <li><a href="developing_11.html">UI上的Data Binding</a></li>
                                    <li><a href="developing_12.html">Windows 8.1和WP 8 Sharing应用分享功能实现</a></li>
                                    <li><a href="developing_13.html">多媒体</a></li>
                                    <li><a href="developing_14.html">后台任务和多任务处理</a></li>
                                    <li><a href="developing_15.html">获取后台服务器数据</a></li>
                                    <li><a href="developing_16.html">浏览器控件WebView</a></li>
                                    <li><a href="developing_17.html">数据库（SQLite）</a></li>
                                    <li><a href="developing_18.html">数据网络和数据通讯</a></li>
                                    <li><a href="developing_19.html">通话和短信功能</a></li>
                                    <li><a href="developing_20.html">图形处理(Drawing & Animation)</a></li>
                                    <li><a href="developing_21.html">文件系统和应用设置</a></li>
                                    <li><a href="developing_22.html">应用间通信</a></li>
                                    <li><a href="developing_23.html">支付方式</a></li>
                                    <li><a href="developing_24.html">Windows 8.1应用外设开发</a></li>
                                </ul>
                            </div>
                            <div class="menu">
                                <h3><a href="testing.html">测试<span>Testing</span></a></h3>
                                <ul>
                                    <li><a href="testing_01.html">Windows 8 and WP 8开发FAQ</a></li>
                                </ul>
                            </div>
                            <div class="menu last">
                                <h3><a href="distribute.html">发布<span>Distribute</span></a></h3>
                                <ul>
                                    <li><a href="distribute_01.html">应用商店(发布和更新应用)</a></li>
                                </ul>
                            </div>
                        </div>
                        <div class="block success-story-nav-block">
                            <h2>成功案例</h2>
                        </div>
                        <div class="block others">
                            <a href="sample_code.html" class="left">示例代码</a>
                            <a href="http://msdn.microsoft.com/zh-cn/dn473954" class="right">教学视频</a>
                        </div>
                    </div>
                    <div class="content">
                        <h3 class="title">推送通知服务<span><a href="index.html">返回首页&gt;</a></span></h3>
                        <div class="article-content">
                            <div class="WordSection1">
                                <p class="MsoToc1"><a href="#_Toc372646814">概述</a></p>
                                <p class="MsoToc1"><a href="#_Toc372646815">各平台推送通知服务</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646816">Windows phone 8推送通知MPNS</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646817">Windows应用商店应用推送通知服务WNS</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646818">Android推送通知服务GCM</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646819">IOS推送服务APNS</a></p>
                                <p class="MsoToc1"><a href="#_Toc372646820">工作原理和流程</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646821">Windows phone 8</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646822">Windows 应用商店应用</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646823">Android</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646824">IOS</a></p>
                                <p class="MsoToc1"><a href="#_Toc372646825">WP/Win8的三种通知</a></p>
                                <p class="MsoToc2">
                                    <a href="#_Toc372646826">Toast通知(Toast
Notification) 10</a>
                                </p>
                                <p class="MsoToc3"><a href="#_Toc372646827">示例</a></p>
                                <p class="MsoToc2">
                                    <a href="#_Toc372646828">Tile通知(Tile
Notification) 16</a>
                                </p>
                                <p class="MsoToc3"><a href="#_Toc372646829">示例</a></p>
                                <p class="MsoToc2"><a href="#_Toc372646830">原生通知(Raw Notification) 21</a></p>
                                <p class="MsoToc3"><a href="#_Toc372646831">示例</a></p>
                                <br />
                                <h1><a name="_Toc372646814">概述</a></h1>
                                <p>通常情况下，用户主动向服务器发出请求，服务器才会向用户传送数据，推送服务（Push Notification）的出现改变了这一状况，其思想是将浏览器主动请求信息改变为服务器主动发送信息。服务器发送一批数据，浏览器显示这些数据，同时保证与服务器的连接。当服务器需要再次发送一批数据时，浏览器显示数据并保持连接。以后，服务器仍然可以发送批量数据，浏览器继续显示数据，依次类推。Android、IOS、Windows平台上都有自己的推送服务，其中Android平台上还出现了第三方推送服务，其功能基本相同，只不过工作流程上略有差异。</p>
                                <h1><a name="_Toc372646815">各平台推送通知服务</a></h1>
                                <p>
                                    无论是Windows phone 8、Windows 8还是Android和IOS还是都提供推送通知的服务，例如Windows phone 8的MPNS、win8的WNS、Android的GCM和IOS的APNS。微软早在Windows
Mobile时代的Push Mail就是完成推送通知的技术，如今的MPNS具有安全、可靠、使用方便的特点。
                                </p>
                                <h2><a name="_Toc372646816">Windows phone 8推送通知MPNS</a></h2>
                                <p>
                                    推送通知是Windows Phone 上的内置特性，开发者可以利用Windows Phone的消息推送服务来实现网络服务器向手机客户端推送一些通知或者消息。Microsoft Push Notification Service 是Windows
Phone 上的一个异步的、尽力的服务，向第三方应用程序开发者提供了一条高效能的从云端向Windows
Phone 应用程序传递数据的通道。
                                </p>
                                <p>Windows Phone的推送通知有3种不同的类型，分别是原生通知(Raw Notification)、Toast通知(Toast Notification)和磁贴通知(Tile Notification)。这三种通知的表现形式和消息传送的格式各不相同，可以根据应用的具体情况来选择需要的通知形式。</p>
                                <h2><a name="_Toc372646817">Windows应用商店应用推送通知服务WNS</a></h2>
                                <p>
                                    Windows
推送通知服务 (WNS)
使第三方开发人员可从自己的云服务发送 Toast、磁贴、锁屏提醒和原始更新。这提供了一种高效而可靠地向用户提供新更新的机制。
                                </p>
                                <p>
                                    Windows应用商店应用的推送通知服务与Windows
Phone的应用的推送通知服务基本相同，其工作流程也没有太多差异，故在此不再详细讲述，详请参见上一小节：Windows
phone 8推送通知MPNS。
                                </p>
                                <h2><a name="_Toc372646818">Android推送通知服务GCM</a></h2>
                                <p>
                                    Android
Cloud to Device Messaging(C2DM)是作为Android 2.2系统的一部分发布的，C2DM允许第三方开发者开发相关应用来推送少量数据信息（1024 字节）到用户的手机上，他允许我们使用多种Google开发工具来创建一种简单但是相当实用的应用类型，用户可以使用该类型的应用把各种各样的信息从他们的服务端直接推送到手机上，不过，谷歌官方已经于2012年6月26日正式弃用，取而代之的是新版的Google Cloud Messaging for Android(GCM)服务，这意味着C2DM已经停止接受新用户和配额请求，也不会有新的特性被加入到C2DM中，然而，使用C2DM的应用让然会继续工作，现有的C2DM开发者都被鼓励迁移到新的GCM上，同时，开发者在开发新的应用的时候必须要使用GCM。
                                </p>
                                <p>
                                    Google
Cloud Messaging for Android(GCM) 允许你从服务器发送数据到安卓设备中，同时也可以利用这个连接来接收安卓设备发过来的数据。GCM服务处理各方面的消息队列，并将其传递到运行安卓应用程序的目标设备上。无论发送的消息多么大GCM都是完全免费的，并且没有配额的限制。GCM消息应该是一个轻量级的消息，提醒应用程序需要在服务器上获取新的数据（例如：“新邮件”提醒可以提示应用程序去服务器上同步邮件），或者它也可以包含不超过4KB的有效载荷数据（这样，即时通讯类的应用程序就可以直接来传递消息）。
                                </p>
                                <p>下面是GCM服务的一些特性：</p>
                                <p>●它允许第三方应用程序服务器向安卓应用程序发送消息。</p>
                                <p>
                                    ●使用<a
                                        href="http://developer.android.com/google/gcm/ccs.html">GCM云连接服务器</a>，你可以接受用户设备上传过来的消息。
                                </p>
                                <p>●安卓设备上的应用程序不需要保持运行来接收消息，当消息到达时，只要应用程序建立了适当的广播接收机制和权限，系统就会通过内部广播通知来唤醒应用程序。</p>
                                <p>●它并没有提供任何内置的用户界面或处理数据的机制，GCM只是简单的将接收到的原始数据直接传递给应用程序，应用程序对接收到的数据有着完全控制权限。例如，应用程序会发送一条通知、显示一个自定义的用户界面，或者在后台同步数据。</p>
                                <p>●它需要在设备上运行安卓2.2或者更高的版本并且安装有谷歌应用商店，或者运行带有谷歌API的安卓2.2的模拟器。然而你可以不受限制的通过谷歌应用商店来部署你的应用程序。</p>
                                <p>●它需要一个已经存在的谷歌服务连接，对于安卓3.0之前的设备，这需要用户在移动设备中登陆他们的谷歌账户，对于安卓4.0.4或更高版本，谷歌账户并不是必须的。</p>
                                <h2><a name="_Toc372646819">IOS推送服务APNS</a></h2>
                                <p>
                                    APNS（Apple Push
Notification Services）是苹果公司官方提供的消息推送服务，也是IOS上唯一的消息推送服务，任何想要使用推送服务的APP都必须使用此项服务。每台设备要与推送服务建立起加密认证的IP连接并通过这个持续的连接来接收通知。如果通知到达的时候应用程序没有在运行，则设备会提示用户该应用程序有数据等待处理。
                                </p>
                                <p>应用开发者（供应商）在他们的服务器软件中生成通知消息，供应商通过一个持续的安全的通道与APNS进行连接并同时监视要发送到客户端程序中的数据，当新的数据到达时，提供者就会准备好并通过上面的通道将通知发送到APNS，这会将通知推送到目标设备中。</p>
                                <p>
                                    除了是一个简单有效的高容量转发服务，APNS还包括一个默认的服务质量组件提供存储转发能力，更多信息请参阅“<a
                                        href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW4">服务质量</a>”。
                                </p>
                                <p>苹果推送通知服务从一个指定的供应商到一个指定的设备传输通知，一条通知是一个由两个主要部分组成的短消息：设备令牌和有效载荷。设备令牌是一种类似于电话号码的东西，它包含了能够使APNS定位到安装了客户端程序的设备上。APNS也使用设备令牌来验证一条通知的路由。有效载荷是一条JSON定义的属性列表，指定了设备上的应用程序如何来提醒用户。</p>
                                <p>
                                    关于设备令牌的更多信息，请参见“<a
                                        href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW3">安全体系</a>”，关于通知有效载荷的更多信息，请参见“<a
                                            href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW1">通知有效载荷</a>”。
                                </p>
                                <h1><a name="_Toc372646820">工作原理和流程</a></h1>
                                <h2><a name="_Toc372646821">Windows phone 8</a></h2>
                                <p>下图展示了推送消息是如何发送的。</p>
                                <p class="imgp">
                                    <img border="0" width="554" height="305" id="图片 9"
                                        src="images/developing_08/image001.png">
                                </p>
                                <p>1、你的应用程序向推送客户端服务发送一个推送URI的请求。</p>
                                <p>
                                    2、推送客户端服务与Microsoft
Push Notification Service交互，然后MPNS向推送客户端服务返回一条通知URI。
                                </p>
                                <p>3、推送客户端服务将通知URI返回给你的应用程序。</p>
                                <p>4、你的应用程序将推送URI发送到你的云服务中。</p>
                                <p>5、当你的云服务需要向你的应用程序发送消息的时候，他使用这个通知URI向MPNS发送一条通知。</p>
                                <p>6、MPNS将这条推送通知发送到你的应用程序。</p>
                                <p>
                                    根据推送通知的格式以及附加的有效载荷，该信息以原始数据的形式被发送给应用程序，然后应用程序的图标会被更新，或者显示toast通知。在发送完推送通知之后，MPNS给你的云服务会返回一个回执码，表示该消息已经被MPNS接收并将在何时的时机发送给目标设备。尽管MPNS并没有提供端到端的服务来确认你的推送通知已经从你的云服务发送到了你的手机中，如果该条消息不能被发送到设备中，MPNS会向你的云服务中返回一条错误码。更多关于回执和错误码的信息，请参见<a
                                        href="http://msdn.microsoft.com/en-us/library/windowsphone/develop/ff941100(v=vs.105).aspx">Windows
Phone推送通知服务的响应代码</a>。在MPNS表明消息无法被传递的时候，你的服务应该在需要的情况下重新提交这条消息。
                                </p>
                                <h2><a name="_Toc372646822">Windows 应用商店应用</a></h2>
                                <p>
                                    下图显示了发送推送通知过程中涉及的完整数据流：
                                </p>
                                <p class="imgp">
                                    <img border="0" width="554" height="401" id="图片 1"
                                        src="images/developing_08/image002.png">
                                </p>
                                <p>其中包括以下步骤：</p>
                                <p style='margin-left: 18.0pt;'>
                                    1.
你的应用向通知客户端平台发送推送通知通道的请求。
                                </p>
                                <p style='margin-left: 18.0pt;'>
                                    2.
通知客户端平台请求 WNS 创建一个通知通道。该通道以统一资源标识符 (URI) 的形式返回调用设备。
                                </p>
                                <p style='margin-left: 18.0pt;'>
                                    3.
通知通道 URI 由 Windows 返回到你的应用。
                                </p>
                                <p style='margin-left: 18.0pt;'>
                                    4.
你的应用将 URI 发送到你自己的云服务。此回调机制是你自己的应用与你自己的服务之间的一个接口。你需要负责以安全保密的 Web 标准实现此回调。
                                </p>
                                <p style='margin-left: 18.0pt;'>
                                    5.
当你的云服务要发送一个更新时，它会使用该通道 URI 通知 WNS。此任务通过使用安全套接字层 (SSL) 发送 HTTP POST 请求（包括通知负载）来完成。此步骤要求进行身份验证。
                                </p>
                                <p style='margin-left: 18.0pt;'>
                                    6.
WNS 接收到请求并将该通知路由到相应的设备。
                                </p>
                                <h2><a name="_Toc372646823">Android</a></h2>
                                <p>一个GCM的实现包括了谷歌提供的连接服务器，与连接服务器交互的第三方应用程序服务器，和在安卓设备上运行的启用了GCM的客户端应用程序。</p>
                                <p class="imgp">
                                    <img border="0" width="554" height="209" id="图片 8"
                                        src="images/developing_08/image003.png">
                                </p>
                                <p>下面解释了这些部分如何交互的</p>
                                <p>
                                    ●谷歌提供的GCM连接服务器从第三方应用程序服务器上获取消息，然后将消息发送到运行在设备上的启用了GCM的安卓应用程序（客户端应用）。截至目前，谷歌为<a
                                        href="http://developer.android.com/google/gcm/http.html">HTTP</a>&nbsp;和&nbsp;<a
                                            href="http://developer.android.com/google/gcm/ccs.html">XMPP</a>提供连接服务器。
                                </p>
                                <p>●第三方应用程序服务器是你和你所选择的GCM连接服务器实施工作的一个组件，应用程序服务器将消息发送到GCM连接服务器，连接服务器将这些消息加入队列名存储，然后当设备在线的时候将其发送给设备。更多信息请参见<a href="http://developer.android.com/google/gcm/server.html">实现GCM服务器</a>。</p>
                                <p>●客户端应用程序是运行在设备上的启用了GCM的的应用程序。为了接收GCM消息，应用程序必须和GCM注册，并获取到注册ID，如果你使用<a href="http://developer.android.com/google/gcm/ccs.html">XMPP</a>(CCS)连接服务器，则客户端可以使用上传数据流来向服务端发送消息。关于实现客户端应用的更多信息，请参见<a href="http://developer.android.com/google/gcm/client.html">实现GCM客户端</a>。</p>
                                <h2><a name="_Toc372646824">IOS</a></h2>
                                <p>推送通知的数据流是单向的，供应商为客户端应用程序创建一条包含了设备令牌的通知和有效载荷，供应商将通知发送到APNS，反过来APNS又将通知推送到设备中。</p>
                                <p>
                                    当供应商验证自身身份到APNS之后
他会将自己的主题发送到APNS服务器，这个主题标识了它将会向哪个应用程序提供数据。主题目前也是绑定目标应用程序的标识符。
                                </p>
                                <p style='margin-left: 21.0pt'>下图表示了一条推送通知从供应商到客户端应用程序的路径。</p>
                                <p class="imgp">
                                    <img border="0" width="554" height="76" id="图片 2"
                                        src="images/developing_08/image004.jpg">
                                </p>
                                <p>上图是一个大大简化了的APNS虚拟网络，实际情况中，APNS的设备端和供应商端都有许多连接点。在供应商那一侧的连接点叫做网关。有许多供应商，每个供应商都通过网关和APNS维持一个或多个持续的安全连接，这些供应商通过APNS向安装了他们应用程序的设备上推送通知，下图是一个比较接近实际的描述。</p>
                                <p class="imgp">
                                    <img border="0" width="416" height="231" id="图片 3"
                                        src="images/developing_08/image005.jpg">
                                </p>
                                <p>
                                    回执服务向供应商提供关于消息无法被成功送达的消息，例如因为目标应用程序已经从设备上卸载。更多信息，请参见“<a
                                        href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/CommunicatingWIthAPS.html#//apple_ref/doc/uid/TP40008194-CH101-SW3">回执服务</a>”。
                                </p>
                                <h1><a name="_Toc372646825">WP/Win8的三种通知</a></h1>
                                <h2><a name="_Toc372646826">Toast通知(Toast Notification)</a></h2>
                                <p>Toast通知是一种直接在屏幕最上面弹出来的系统提示栏通知，总是显示在屏幕最顶部，会有声音和震动提示，十秒钟后悔自动消失，当单击提示栏时可以打开应用程序。例如，手机接收到新短信的时候，在屏幕顶端弹出来的消息就是Toast通知，单击进去就进入了短信的界面。Toast通知一般用于比较重要的通知提示，比如短信提醒、恶劣天气提醒等。</p>
                                <p>Toast通知的特定：</p>
                                <p>(1)发送的数据为指定的XML格式；</p>
                                <p>(2)如果程序正在运行，内容发送到应用程序中；</p>
                                <p>(3)如果程序不在运行，弹出Toast消息框显示消息；</p>
                                <p>(4)会临时打断用户的操作；</p>
                                <p>(5)消息的内容为App图标加上两个标题描述，标题为粗体字显示的字符串，副标题为非粗体字显示的字符串；</p>
                                <p>(6)用户可以单击消息进行跟踪。</p>
                                <p>Toast消息的传送格式如下：</p>
                                <textarea><?xml version = “1.0” encoding = “uft – 8”?>
		<wp : Notificaitonxmlns : wpwp : Notificationxmlns : wp = “WPNotification”>
			<wp : Toast>
				<wp : Text1>
					标题
					</wp : Text1>
					<wp : Text2>
					副标题
					</wp : Text2>
			</wp : Toast>
	</wp : Notification></textarea>
                                <h3><a name="_Toc372646827">示例</a></h3>
                                <h4>创建Toast通知发送端</h4>
                                <p>创建一个ASP.NET应用，为应用添加一个表单页面并设为首页，为表单添加以下控件：</p>
                                <p class="imgp">
                                    <img
                                        border="0" width="521" height="236" id="图片 5" src="images/developing_08/image006.png">
                                </p>
                                <p>为ButtonSendToast添加Click处理程序：</p>
                                <textarea>protected void ButtonSendToast_Click(object sender, EventArgs e)
        {
            try
            {
=                string subscriptionUri = TextBoxUri.Text.ToString();

                HttpWebRequest sendNotificationRequest = (HttpWebRequest)WebRequest.Create(subscriptionUri);

                sendNotificationRequest.Method = "POST";

                string toastMessage = "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                "<wp:Notification xmlns:wp=\"WPNotification\">" +
                   "<wp:Toast>" +
                        "<wp:Text1>" + TextBoxTitle.Text.ToString() + "</wp:Text1>" +
                        "<wp:Text2>" + TextBoxSubTitle.Text.ToString() + "</wp:Text2>" +
                        "<wp:Param>/Page2.xaml?NavigatedFrom=Toast Notification</wp:Param>" +
                   "</wp:Toast> " +
                "</wp:Notification>";

                // Set the notification payload to send.
                byte[] notificationMessage = Encoding.Default.GetBytes(toastMessage);

                // Set the web request content length.
                sendNotificationRequest.ContentLength = notificationMessage.Length;
                sendNotificationRequest.ContentType = "text/xml";
                sendNotificationRequest.Headers.Add("X-WindowsPhone-Target", "toast");
                sendNotificationRequest.Headers.Add("X-NotificationClass", "2");
                using (Stream requestStream = sendNotificationRequest.GetRequestStream())
                {
                    requestStream.Write(notificationMessage, 0, notificationMessage.Length);
                }

                // Send the notification and get the response.
                HttpWebResponse response = (HttpWebResponse)sendNotificationRequest.GetResponse();
                string notificationStatus = response.Headers["X-NotificationStatus"];
                string notificationChannelStatus = response.Headers["X-SubscriptionStatus"];
                string deviceConnectionStatus = response.Headers["X-DeviceConnectionStatus"];

                TextBoxResponse.Text = notificationStatus + " | " + deviceConnectionStatus + " | " + notificationChannelStatus; 
            }
            catch (Exception ex)
            {
                TextBoxResponse.Text = "Exception caught sending update: " + ex.ToString();
            }

        }</textarea>
                                <h4>创建Toast通知接受端</h4>
                                <p>
                                    创建windows
phone应用
                                </p>
                                <p>
                                    为了演示在 Toast 消息中传递参数和导航信息，将添加另一个页面。MainPage 上的一个按钮将导航到第二个页面，并传递设置为<b>“主页”</b>的&nbsp;<i>NavigatedFrom</i>&nbsp;的参数。通过将<b>MainPage.xaml</b>&nbsp;中的&nbsp;&lt;Grid x:Name=&quot;ContentPanel&quot;
Grid.Row=&quot;1&quot; Margin=&quot;12,0,12,0&quot;&gt;&lt;/Grid&gt;&nbsp;替换为以下代码：
                                </p>
                                <textarea><Grid x:Name="ContentPanel" Grid.Row="1" Margin="12,0,12,0">
            <Button Content="Navigate to Page 2" Height="72" HorizontalAlignment="Left" 
              Margin="83,82,0,0" Name="buttonNavigate" VerticalAlignment="Top" Width="281" 
              Click="buttonNavigate_Click" />
        </Grid></textarea>
                                <p>
                                    为应用添加名为Page2的页面，并将Page2.xaml 中的&nbsp;&lt;Grid x:Name=&quot;ContentPanel&quot;
Grid.Row=&quot;1&quot; Margin=&quot;12,0,12,0&quot;&gt;&lt;/Grid&gt;&nbsp;替换为以下代码：
                                </p>
                                <textarea>Grid.Row="1" Margin="12,0,12,0"></Grid> 替换为以下代码：
<Grid x:Name="ContentPanel" Grid.Row="1" Margin="12,0,12,0">
            <TextBlock Height="33" HorizontalAlignment="Left" Margin="36,87,0,0" Name="textBlockFrom" Text="" VerticalAlignment="Top" Width="390" />
        </Grid></textarea>
                                <p>用下面的代码替换 MainPage 构造函数。该代码查看在应用的早期实例中是否已设置 Toast 通知通道。如果找到通知通道，则通知通道连接到通知事件。如果未找到通知通道，则创建通知通道，然后将其连接到通知事件：</p>
                                <pre><code>public MainPage()
        {
            /// Holds the push channel that is created or found.
            HttpNotificationChannel pushChannel;

            // The name of our push channel.
            string channelName = "ToastSampleChannel";

            InitializeComponent();

            // Try to find the push channel.
            pushChannel = HttpNotificationChannel.Find(channelName);

            // If the channel was not found, then create a new connection to the push service.
            if (pushChannel == null)
            {
                pushChannel = new HttpNotificationChannel(channelName);

                // Register for all the events before attempting to open the channel.
                pushChannel.ChannelUriUpdated += new EventHandler<NotificationChannelUriEventArgs>(PushChannel_ChannelUriUpdated);
                pushChannel.ErrorOccurred += new EventHandler<NotificationChannelErrorEventArgs>(PushChannel_ErrorOccurred);

                // Register for this notification only if you need to receive the notifications while your application is running.
                pushChannel.ShellToastNotificationReceived += new EventHandler<NotificationEventArgs>(PushChannel_ShellToastNotificationReceived);
                
                pushChannel.Open();

                // Bind this new channel for toast events.
                pushChannel.BindToShellToast();

            }
            else
            {
                // The channel was already open, so just register for all the events.
                pushChannel.ChannelUriUpdated += new EventHandler<NotificationChannelUriEventArgs>(PushChannel_ChannelUriUpdated);
                pushChannel.ErrorOccurred += new EventHandler<NotificationChannelErrorEventArgs>(PushChannel_ErrorOccurred);

                // Register for this notification only if you need to receive the notifications while your application is running.
                pushChannel.ShellToastNotificationReceived += new EventHandler<NotificationEventArgs>(PushChannel_ShellToastNotificationReceived);

                // Display the URI for testing purposes. Normally, the URI would be passed back to your web service at this point.
                System.Diagnostics.Debug.WriteLine(pushChannel.ChannelUri.ToString());
                MessageBox.Show(String.Format("Channel Uri is {0}",
                    pushChannel.ChannelUri.ToString()));

            }
        }</code></pre>
                                <p>
                                    为推送通知添加&nbsp;<a
                                        href="http://msdn.microsoft.com/zh-cn/library/windowsphone/develop/microsoft.phone.notification.httpnotificationchannel.channeluriupdated(v=vs.105).aspx">ChannelUriUpdated</a>事件处理程序的代码：
                                </p>
                                <pre><code>void PushChannel_ChannelUriUpdated(object sender, NotificationChannelUriEventArgs e)
        {

            Dispatcher.BeginInvoke(() =>
            {
                // Display the new URI for testing purposes.   Normally, the URI would be passed back to your web service at this point.
                System.Diagnostics.Debug.WriteLine(e.ChannelUri.ToString());
                MessageBox.Show(String.Format("Channel Uri is {0}",
                    e.ChannelUri.ToString()));
                
            });
        }</code></pre>
                                <p>为推送通知添加错误处理事件处理代码：</p>
                                <pre><code>void PushChannel_ErrorOccurred(object sender, NotificationChannelErrorEventArgs e)
        {
            // Error handling logic for your particular application would be here.
            Dispatcher.BeginInvoke(() =>
                MessageBox.Show(String.Format("A push notification {0} error occurred.  {1} ({2}) {3}",
                    e.ErrorType, e.Message, e.ErrorCode, e.ErrorAdditionalData))
                    );
        }</code></pre>
                                <p>
                                    为 Page2.xaml 添加
OnNavigatedTo 事件处理程序。文本块显示传递给页面的<i>NavigatedFrom</i>&nbsp;参数的值：
                                </p>
                                <pre><code>protected override void OnNavigatedTo(System.Windows.Navigation.NavigationEventArgs e)
        {
            base.OnNavigatedTo(e);
            textBlockFrom.Text = "Navigated here from " + this.NavigationContext.QueryString["NavigatedFrom"];
        }</code></pre>
                                <h4>运行效果</h4>
                                <p class="imgp">
                                    <img border="0" width="528" height="345" id="图片 6"
                                        src="images/developing_08/image007.png">
                                </p>
                                <h2><a name="_Toc372646828">Tile通知(Tile Notification)</a></h2>
                                <p><b></b>磁贴通知是一种针对于在开始屏幕上的应用程序提供的通知，如果应用程序不再开始屏幕中是不会接收到磁贴通知的。磁贴通知有三个元素：计数器(Count)、标题(Title)和背景(Background)。计数器是展现在磁贴图标右上角的数字，标题是展现在图标左下角的文本文字，背景图像则可以改变这个图标的背景。</p>
                                <p>磁贴通知的特点：</p>
                                <p>(1)发送的数据为指定的XML格式；</p>
                                <p>(2)不会向应用程序内部进行发送；</p>
                                <p>(3)可以改变开始屏幕中图标的内容（图片、文字等）；</p>
                                <p>(4)包含三个属性：背景、标题和计数器，每个属性都有固定的格式和位置，可以使用其中的一种属性，不一定三个属性一起使用。</p>
                                <p>磁贴通知的传送格式如下：</p>
                                <textarea><?xml version = “1.0” encoding = “uft – 8”?>
		<wp : Notificaitonxmlns : wpwp : Notificationxmlns : wp = “WPNotification”>
			<wp : Tile>
				<wp : BackgroundImage>
					背景图像
					<BackgroundImagePath>
				</wp : BackgroundImage>
				<wp : Count>
					计数器
					<Count>
				</wp : Count>
				<wp : Title>
					标题
					<Title>
				</wp : Title>
			</wp : Tile>
		</wp : Notification></textarea>
                                <h3><a name="_Toc372646829">示例</a></h3>
                                <h4>创建Tile通知发送端</h4>
                                <p>创建一个ASP.NET应用，为应用添加一个表单页面并设为首页，为表单添加以下控件：</p>
                                <p class="imgp">
                                    <img
                                        border="0" width="554" height="392" id="图片 7" src="images/developing_08/image008.png">
                                </p>
                                <p>为&nbsp;<b>ButtonSendTile</b>添加&nbsp;<b>Click</b>&nbsp;事件处理程序的代码，该代码将获取在第一个 TextBox 中输入的 URI，形成图块通知消息，然后将其发布到 Microsoft 推送通知服务：</p>
                                <textarea>protected void ButtonSendTile_Click(object sender, EventArgs e)
        {
            try
            {
                string subscriptionUri = TextBoxUri.Text.ToString();

                HttpWebRequest sendNotificationRequest = (HttpWebRequest)WebRequest.Create(subscriptionUri);

                sendNotificationRequest.Method = "POST";

                  string tileMessage = "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                  "<wp:Notification xmlns:wp=\"WPNotification\">" +
                      "<wp:Tile>" +
                        "<wp:BackgroundImage>" + TextBoxBackgroundImage.Text + "</wp:BackgroundImage>" +
                        "<wp:Count>" + TextBoxCount.Text + "</wp:Count>" +
                        "<wp:Title>" + TextBoxTitle.Text + "</wp:Title>" +
                        "<wp:BackBackgroundImage>" + TextBoxBackBackgroundImage.Text + "</wp:BackBackgroundImage>" +
                        "<wp:BackTitle>" + TextBoxBackTitle.Text + "</wp:BackTitle>" +
                        "<wp:BackContent>" + TextBoxBackContent.Text + "</wp:BackContent>" +
                     "</wp:Tile> " +
                  "</wp:Notification>";
 
                // Set the notification payload to send.
                byte[] notificationMessage = Encoding.Default.GetBytes(tileMessage);

                // Set the web request content length.
                sendNotificationRequest.ContentLength = notificationMessage.Length;
                sendNotificationRequest.ContentType = "text/xml";
                sendNotificationRequest.Headers.Add("X-WindowsPhone-Target", "token");
                sendNotificationRequest.Headers.Add("X-NotificationClass", "1");
                using (Stream requestStream = sendNotificationRequest.GetRequestStream())
                {
                    requestStream.Write(notificationMessage, 0, notificationMessage.Length);
                }

                // Send the notification and get the response.
                HttpWebResponse response = (HttpWebResponse)sendNotificationRequest.GetResponse();
                string notificationStatus = response.Headers["X-NotificationStatus"];
                string notificationChannelStatus = response.Headers["X-SubscriptionStatus"];
                string deviceConnectionStatus = response.Headers["X-DeviceConnectionStatus"];

                TextBoxResponse.Text = notificationStatus + " | " + deviceConnectionStatus + " | " + notificationChannelStatus;
            }
            catch (Exception ex)
            {
                TextBoxResponse.Text = "Exception caught sending update: " + ex.ToString();
            }

        }</textarea>
                                <h4>创建Tile通知接受端</h4>
                                <p>
                                    创建一个新的
Windows&nbsp;Phone 应用，用下面的代码替换 MainPage 构造函数。该代码查看在应用程序的早期实例中是否已设置图块通知通道。如果找到通知通道，则通知通道连接到通知事件。如果未找到通知通道，则创建通知通道，然后将其连接到通知事件：
                                </p>
                                <pre><code>public MainPage()
        {
            /// Holds the push channel that is created or found.
            HttpNotificationChannel pushChannel;

            // The name of our push channel.
            string channelName = "TileSampleChannel";

            InitializeComponent();

            // Try to find the push channel.
            pushChannel = HttpNotificationChannel.Find(channelName);

            // If the channel was not found, then create a new connection to the push service.
            if (pushChannel == null)
            {
                pushChannel = new HttpNotificationChannel(channelName);

                // Register for all the events before attempting to open the channel.
                pushChannel.ChannelUriUpdated += new EventHandler<NotificationChannelUriEventArgs>(PushChannel_ChannelUriUpdated);
                pushChannel.ErrorOccurred += new EventHandler<NotificationChannelErrorEventArgs>(PushChannel_ErrorOccurred);

                pushChannel.Open();

                // Bind this new channel for Tile events.
                pushChannel.BindToShellTile();

            }
            else
            {
                // The channel was already open, so just register for all the events.
                pushChannel.ChannelUriUpdated += new EventHandler<NotificationChannelUriEventArgs>(PushChannel_ChannelUriUpdated);
                pushChannel.ErrorOccurred += new EventHandler<NotificationChannelErrorEventArgs>(PushChannel_ErrorOccurred);

                // Display the URI for testing purposes. Normally, the URI would be passed back to your web service at this point.
                System.Diagnostics.Debug.WriteLine(pushChannel.ChannelUri.ToString());
                MessageBox.Show(String.Format("Channel Uri is {0}",
                    pushChannel.ChannelUri.ToString()));

            }
        }</code></pre>
                                <p>推送通知的ChannelUriUpdated和ErrorOccurred事件与Toast相同</p>
                                <h4>运行效果</h4>
                                <p class="imgp">
                                    <img
                                        border="0" width="123" height="149" id="图片 10" src="images/developing_08/image009.png">
                                </p>
                                <p>如果您设置图块背面的任何属性，则几秒之后图块将翻转图块以显示其背面。如果您将某个字段保留空白（如<b>“标题”</b>），则不会更新该字段。</p>
                                <h2><a name="_Toc372646830">原生通知(Raw Notification)</a></h2>
                                <p>原生通知是一种只针对于正在运行的应用程序而提供的通知，如果使用了原生通知的应用程序没有运行，而服务器又给应用程序发送了消息的情况下，那么这一条原生通知就会被微软的推送服务器所丢弃。原生通知一般都是一般是用于给正在运行的应用程序发送消息，比如即时通讯软件的好友上线通知等。</p>
                                <p>原生通知具有以下特点：</p>
                                <p>(1)可以发送任何格式的数据；</p>
                                <p>(2)有效载荷最大为1KB；</p>
                                <p>(3)只有在使用原生通知的应用程序运行的情况下才能接收到消息。</p>
                                <p>(4)允许在用户使用时更新用户界面。</p>
                                <p>原生通知的传送格式可以是任意的字符串格式。</p>
                                <h3><a name="_Toc372646831">示例</a></h3>
                                <h4>创建原生通知发送端</h4>
                                <p>创建方式与以上两种通知相同，不同的是表单控件和按钮的Click处理事件，原生通知的表单控件如下：</p>
                                <p class="imgp">
                                    <img
                                        border="0" width="526" height="235" id="图片 11" src="images/developing_08/image010.png">
                                </p>
                                <p>ButtonSendRaw的Click事件处理程序如下：</p>
                                <textarea>protected void ButtonSendRaw_Click(object sender, EventArgs e)
        {
            try
            {
                string subscriptionUri = TextBoxUri.Text.ToString();


                HttpWebRequest sendNotificationRequest = (HttpWebRequest)WebRequest.Create(subscriptionUri);

                sendNotificationRequest.Method = "POST";

                // Create the raw message.
                string rawMessage = "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                "<root>" +
                    "<Value1>" + TextBoxValue1.Text.ToString() + "<Value1>" +
                    "<Value2>" + TextBoxValue2.Text.ToString() + "<Value2>" +
                "</root>";

                // Set the notification payload to send.
                byte[] notificationMessage = Encoding.Default.GetBytes(rawMessage);

                // Set the web request content length.
                sendNotificationRequest.ContentLength = notificationMessage.Length;
                sendNotificationRequest.ContentType = "text/xml";
                sendNotificationRequest.Headers.Add("X-NotificationClass", "3");

                using (Stream requestStream = sendNotificationRequest.GetRequestStream())
                {
                    requestStream.Write(notificationMessage, 0, notificationMessage.Length);
                }

                // Send the notification and get the response.
                HttpWebResponse response = (HttpWebResponse)sendNotificationRequest.GetResponse();
                string notificationStatus = response.Headers["X-NotificationStatus"];
                string notificationChannelStatus = response.Headers["X-SubscriptionStatus"];
                string deviceConnectionStatus = response.Headers["X-DeviceConnectionStatus"];

                TextBoxResponse.Text = notificationStatus + " | " + deviceConnectionStatus + " | " + notificationChannelStatus;
            }
            catch (Exception ex)
            {
                TextBoxResponse.Text = "Exception caught sending update: " + ex.ToString();
            }
        }</textarea>
                                <h4>创建原生通知接受端</h4>
                                <p>创建方式和Toast以及Tile通知基本相同，区别在于原生通知需要添加HttpNotificationReceived事件，事件处理程序如下：</p>
                                <pre><code>void PushChannel_HttpNotificationReceived(object sender, HttpNotificationEventArgs e)
        {
            string message;

            using (System.IO.StreamReader reader = new System.IO.StreamReader(e.Notification.Body))
            {
                message = reader.ReadToEnd();
            }


            Dispatcher.BeginInvoke(() =>
                MessageBox.Show(String.Format("Received Notification {0}:\n{1}",
                    DateTime.Now.ToShortTimeString(), message))
                    );
        }</code></pre>
                                <h4>运行效果</h4>
                                <p class="imgp">
                                    <img
                                        border="0" width="307" height="184" id="图片 12" src="images/developing_08/image011.png">
                                </p>
                                <p>运行的 Windows&nbsp;Phone 应用时，您应该能够收到 Raw 通知。</p>
                                <p><b>注意：</b>仅当应用运行时才会收到此通知</p>
                            </div>
                        </div>
                    </div>
                    <div class="clear"></div>
                </div>
            </div>
        </div>
        <!--End Content-->
        <div style="text-align: right" class="gotoTop"><a href="javascript:scroll(0,0)"></a></div>
        <!--Begin ProudctLinks-->
        <div class="ms-pro-links">
            <div class="grid-container clearfix">
                <div class="cam-links">
                    其它微软站点
		<a href="http://www.microsoft.com/zh-cn/default.aspx">微软中国官方网站</a>
                    <a href="http://www.microsoft.com/zh-cn/download/default.aspx?WT.mc_id=MSCOM_zh-cn_HP_Footer_downloads" target="_blank">微软中国下载中心</a>
                    <a href="http://www.microsoftstore.com.cn?WT.mc_id=MSCOM_003" target="_blank">微软中国官方商城</a>
                    <a href="http://www.microsoft.com/china/newsletter/" target="_blank">订阅电子期刊</a>
                    <a href="https://sales.liveperson.net/hc/21661174/?cmd=file&file=visitorWantsToChat&site=21661174&byhref=1&SESSIONVAR!skill=APGC.PRC.ZH.CS.CON.PRESLS.GENERAL" target="_blank">联系微软销售代表</a>
                    <a href="http://www.microsoft.com/zh-cn/sitemap.aspx" target="_blank">网站地图</a>
                </div>
            </div>
        </div>
        <!--End ProudctLinks-->
        <!--Begin footer-->
        <div class="footer">
            <div class="grid-container">
                <img src="http://i.s-microsoft.com/global/ImageStore/PublishingImages/logos/hp/logo-type-1x.png" alt="microsoft" class="logo">
                <ul>
                    <li><a href="http://www.miibeian.gov.cn/" title="">京ICP备09042378号-6</a></li>
                    <li><a href="https://profile.microsoft.com/RegSysProfileCenter/default.aspx?lcid=2052" title="">个人信息中心</a></li>
                    <li><a href="http://support.microsoft.com/contactus/?ws=support" title="">与我们联系</a></li>
                    <li><a href="http://go.microsoft.com/fwlink/?LinkId=248681" title="">隐私权声明</a></li>
                    <li><a href="http://go.microsoft.com/?linkid=4412892" title="">使用条款</a></li>
                    <li><a href="http://www.microsoft.com/About/Legal/EN/US/IntellectualProperty/Trademarks/EN-US.aspx" title="">商标</a></li>
                    <li>&copy; 2013 Microsoft</li>
                </ul>
            </div>
        </div>
        <!--End footer-->
        <!-- Begin MDA WEDCS -->
        <script type="text/JavaScript">
            var varSegmentation = 0;
            var varClickTracking = 1;
            var varCustomerTracking = 1;
            var varAutoFirePV = 1;
            var Route = "#";
            var Ctrl = "#"
            //document.write("<script type='text/javascript' src='" + window.location.protocol + "//c.microsoft.com/ms.js'><"+"/script>");
        </script>
        <script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
        <script type="text/javascript" src="./assets/js/script.js"></script>
        <script type="text/javascript" src="./js/siteSearch.js"></script>
        <noscript>
            <img alt="" width="1" height="1" src="http://c.microsoft.com/trans_pixel.aspx/" />
        </noscript>
        <!-- Begin MDA WEDCS -->
    </div>
</body>
</html>
